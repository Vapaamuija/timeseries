---
description: Weather Tool Development Rules
alwaysApply: true
---

You are an expert in Python, scientific data visualization, and meteorological data processing.

## Key Principles

-   Write concise, technical responses with accurate Python examples using type hints.
-   Use functional, declarative programming; prefer dataclasses and protocols over complex inheritance.
-   Prioritize modularization and clean interfaces over code duplication.
-   Use descriptive variable names with auxiliary verbs (e.g., `is_valid_data`, `has_weather_symbols`).
-   Use lowercase with underscores for directories and files (e.g., `plotting/components.py`).
-   Favor explicit imports and clear module boundaries.
-   Use the configuration-driven approach with YAML files and dataclasses.

## Python/Weather Tool Specific

-   Use `def` for function definitions with comprehensive type hints.
-   Leverage dataclasses for configuration and data structures.
-   File structure: `src/weather_tool/` with clear module separation (core, data, plotting, airports, utils).
-   Use protocols and abstract base classes for extensible interfaces.
-   Prefer composition over inheritance for plotting components.

## Error Handling and Validation

-   Prioritize error handling and edge cases:
    -   Handle missing weather data gracefully with fallback mechanisms.
    -   Use early returns for invalid ICAO codes, malformed data, or connection failures.
    -   Place the happy path last in functions for improved readability.
    -   Implement proper logging using the configured logger from `utils.logging`.
    -   Use custom exceptions for weather-specific errors (e.g., `DataSourceError`, `PlottingError`).
    -   Validate weather data ranges and units before processing.

## Dependencies

### Core Scientific Stack

-   NumPy (>=1.21.0) - Numerical computations and array operations
-   Pandas (>=1.3.0) - Weather data manipulation and time series
-   Matplotlib (>=3.5.0) - Core plotting functionality
-   Seaborn (>=0.11.0) - Statistical visualization and themes

### Weather Data Processing

-   xarray (>=0.19.0) - Multi-dimensional weather data arrays
-   netCDF4 (>=1.5.7) - NetCDF file format support for THREDDS
-   MetPy (>=1.3.0) - Meteorological calculations and units
-   Cartopy (>=0.20.0) - Geospatial projections and mapping
-   PyProj (>=3.0.0) - Coordinate system transformations

### Data Access and Configuration

-   Requests (>=2.25.0) - HTTP API client for Met.no services
-   PyYAML (>=6.0) - Configuration file parsing
-   Click (>=8.0.0) - Command-line interface framework
-   python-dotenv (>=0.19.0) - Environment variable management

### Development and Testing

-   pytest (>=6.2.0) - Testing framework with visual regression tests
-   pytest-cov (>=2.12.0) - Coverage reporting
-   Black (>=21.0.0) - Code formatting (88 character line length)
-   MyPy (>=0.910) - Static type checking with strict configuration

## Weather Tool Specific Guidelines

### Configuration Management

-   Use YAML configuration files with dataclass-based parsing via `Config.from_file()`.
-   Support environment variable overrides with `Config.from_env()`.
-   Implement configuration validation and directory creation with `config.ensure_directories()`.
-   Use nested configuration classes (`APIConfig`, `THREDDSConfig`, `PlottingConfig`).
-   Support theme-based configuration for dynamic plotting styles.

### Data Architecture

-   Use the unified data client registry pattern with `DataClientRegistry`.
-   Implement data source prioritization (Met.no unified > HTTP > File clients).
-   Use protocol-based interfaces (`WeatherDataClient`, `HTTPWeatherClient`, `FileWeatherClient`).
-   Handle multiple data sources gracefully with automatic fallback.
-   Implement proper caching strategies for weather data.

### Plotting System

-   Use composition-based plotting with specialized components (`NorwegianMeteogramPlotter`).
-   Implement theme-aware plotting with `ThemeManager` and `WeatherTheme`.
-   Support multiple symbol types (SVG weather symbols with transparency).
-   Use `PlotConfig` for centralized plotting configuration.
-   Implement variable selection based on data availability.

### Airport Management

-   Use `AirportManager` for ICAO code validation and airport data.
-   Support multiple airport data sources (CSV files, JSON databases).
-   Implement fuzzy search capabilities for airport lookup.
-   Validate ICAO codes before processing.

## Performance Optimization

-   Use pandas vectorized operations for weather data processing.
-   Implement efficient NetCDF data loading with xarray.
-   Use matplotlib's constrained layout for optimal subplot arrangement.
-   Cache weather symbols and frequently accessed data.
-   Implement parallel processing for multi-airport plots with configurable `max_workers`.

## Key Conventions

### Project Structure

```
src/weather_tool/
‚îú‚îÄ‚îÄ core/           # Configuration and main plotter classes
‚îú‚îÄ‚îÄ data/           # Data access interfaces and clients
‚îú‚îÄ‚îÄ plotting/       # Plotting components and themes
‚îú‚îÄ‚îÄ airports/       # Airport management and validation
‚îî‚îÄ‚îÄ utils/          # Logging, helpers, and utilities
```

### Data Processing

-   Use xarray for multi-dimensional weather data with proper coordinate handling.
-   Implement unit-aware calculations with MetPy.
-   Handle time zones and UTC conversions properly.
-   Support multiple temporal resolutions (hourly, 3-hourly, 6-hourly).

### Plotting Standards

-   Follow Norwegian meteorological visualization standards.
-   Use semantic color mapping for weather variables.
-   Implement proper axis labeling with units and Norwegian formatting.
-   Support high-DPI output (300 DPI default) for publication quality.
-   Use constrained layout for automatic subplot spacing.

### CLI Design

-   Use Click for command-line interface with proper help text.
-   Support both individual and batch airport processing.
-   Implement time range parsing with natural language support.
-   Provide progress indicators for long-running operations.

## Testing Strategy

### Visual Regression Testing

-   Use comprehensive visual regression tests with reference images.
-   Implement multi-metric similarity analysis (MSE, SSIM, Histogram correlation).
-   Test all weather components individually and in combination.
-   Use deterministic test data for reproducible results.

### Unit Testing

-   Test configuration loading and validation.
-   Test data client interfaces and error handling.
-   Test airport validation and search functionality.
-   Test weather data processing and unit conversions.

### Integration Testing

-   Test end-to-end plotting workflows.
-   Test multiple data source fallback mechanisms.
-   Test CLI commands with various parameter combinations.

## Weather Data Handling

-   Validate weather data ranges and units before processing.
-   Handle missing data with appropriate interpolation or masking.
-   Support multiple weather variables (temperature, pressure, precipitation, wind, clouds).
-   Implement proper meteorological calculations (dew point, wind chill, heat index).
-   Use standard meteorological units and conversions.

## Logging and Monitoring

-   Use structured logging with configurable levels.
-   Log data source selection and fallback decisions.
-   Monitor API rate limits and implement respectful request patterns.
-   Log plotting performance metrics and data processing times.

## Documentation Standards

-   Use comprehensive docstrings with type information.
-   Document weather data sources and their characteristics.
-   Provide examples for common plotting scenarios.
-   Document configuration options and their effects.
-   Maintain visual examples in Jupyter notebooks.

## Code Style and Quality

### Type Hints and Documentation

-   Use comprehensive type hints for all function signatures.
-   Document complex weather calculations with inline comments.
-   Use docstrings following NumPy/SciPy documentation standards.
-   Include units in variable names and documentation (e.g., `temp_celsius`, `pressure_hpa`).

### Configuration Patterns

```python
from dataclasses import dataclass, field
from typing import Optional, Dict, Any, List
from pathlib import Path

@dataclass
class WeatherConfig:
    """Weather-specific configuration with validation."""
    api_timeout: int = 30
    cache_dir: Path = Path("data/cache")
    default_variables: List[str] = field(default_factory=lambda: ["temperature", "pressure"])

    def __post_init__(self):
        """Validate configuration after initialization."""
        if self.api_timeout <= 0:
            raise ValueError("API timeout must be positive")
        self.cache_dir.mkdir(parents=True, exist_ok=True)
```

### Data Processing Patterns

```python
import xarray as xr
import pandas as pd
from typing import Optional, Union, List

def process_weather_data(
    data: xr.Dataset,
    variables: Optional[List[str]] = None,
    time_range: Optional[pd.DatetimeIndex] = None
) -> pd.DataFrame:
    """Process weather data with proper error handling."""
    if data is None or data.sizes.get('time', 0) == 0:
        raise ValueError("Empty or invalid weather data")

    # Early return for invalid time range
    if time_range is not None and len(time_range) == 0:
        return pd.DataFrame()

    # Process data (happy path)
    processed = data.to_dataframe()
    if variables:
        available_vars = [v for v in variables if v in processed.columns]
        processed = processed[available_vars]

    return processed
```

### Plotting Component Patterns

```python
from abc import ABC, abstractmethod
from matplotlib.axes import Axes
import matplotlib.pyplot as plt
import pandas as pd

class WeatherComponent(ABC):
    """Base class for weather plot components."""

    @abstractmethod
    def render(self, ax: Axes, data: pd.DataFrame, config: 'PlotConfig') -> None:
        """Render component on the given axes."""
        pass

    def validate_data(self, data: pd.DataFrame) -> bool:
        """Validate required data is present."""
        return not data.empty

class TemperatureComponent(WeatherComponent):
    """Temperature plotting component with zero-crossing colors."""

    def render(self, ax: Axes, data: pd.DataFrame, config: 'PlotConfig') -> None:
        if not self.validate_data(data) or 'temperature' not in data.columns:
            return

        temp_data = data['temperature'].dropna()
        if temp_data.empty:
            return

        # Color-coded temperature line (red above 0¬∞C, blue below)
        positive_mask = temp_data >= 0
        ax.plot(temp_data.index[positive_mask], temp_data[positive_mask],
                color=config.colors.temperature_positive, linewidth=2)
        ax.plot(temp_data.index[~positive_mask], temp_data[~positive_mask],
                color=config.colors.temperature_negative, linewidth=2)
```

### Error Handling Patterns

```python
import logging
from typing import Optional
from enum import Enum

class WeatherDataError(Exception):
    """Base exception for weather data errors."""
    pass

class DataSourceError(WeatherDataError):
    """Error accessing weather data source."""
    pass

def fetch_weather_data(icao_code: str, client: 'WeatherDataClient') -> Optional[pd.DataFrame]:
    """Fetch weather data with comprehensive error handling."""
    logger = logging.getLogger(__name__)

    # Early validation
    if not icao_code or len(icao_code) != 4:
        logger.error(f"Invalid ICAO code: {icao_code}")
        return None

    try:
        # Attempt data fetch
        data = client.get_data(icao_code)
        if data is None or data.empty:
            logger.warning(f"No data available for {icao_code}")
            return None

        # Validate data quality
        if not _validate_weather_data(data):
            logger.error(f"Invalid weather data for {icao_code}")
            return None

        # Happy path
        logger.info(f"Successfully fetched data for {icao_code}")
        return data

    except DataSourceError as e:
        logger.error(f"Data source error for {icao_code}: {e}")
        return None
    except Exception as e:
        logger.error(f"Unexpected error fetching data for {icao_code}: {e}")
        return None
```

## Deployment and Distribution

-   Use setuptools with proper entry points for CLI commands.
-   Support installation via pip with optional dependencies.
-   Provide Docker support for consistent environments.
-   Include comprehensive requirements specification.
-   Support multiple Python versions (3.8+).

Refer to the Met.no API documentation, matplotlib documentation, and xarray documentation for detailed information on weather data access, plotting best practices, and multi-dimensional data handling.

I'll provide clear instructions on how to follow the documentation best practices we just established. Let me first check the current state of the documentation structure to give you comprehensive guidance.

[2 tools called]

# üìö Documentation Best Practices - Clear Instructions

Based on the enhanced documentation structure we just established, here are clear instructions for following the documentation best practices:

## üéØ Core Documentation Principles

### 1. **Always Keep Docs Current** ‚ö†Ô∏è CRITICAL

-   **Rule**: Documentation must be updated with every code change
-   **When to update**:
    -   Add new features ‚Üí Update relevant docs
    -   Change command syntax ‚Üí Update README.md and examples
    -   Modify configuration ‚Üí Update configuration docs
    -   Fix bugs ‚Üí Update troubleshooting guide
    -   Change API ‚Üí Update API reference

### 2. **Follow the Documentation Hierarchy**

```
README.md (Essential overview)
‚îú‚îÄ‚îÄ docs/GETTING_STARTED.md (Beginner setup)
‚îú‚îÄ‚îÄ docs/TROUBLESHOOTING.md (Problem solving)
‚îú‚îÄ‚îÄ docs/EXAMPLES.md (Advanced use cases)
‚îú‚îÄ‚îÄ docs/API_REFERENCE.md (Developer reference)
‚îú‚îÄ‚îÄ docs/CONFIGURATION.md (Customization)
‚îî‚îÄ‚îÄ docs/CONTRIBUTING.md (Contributor guide)
```

## üìù Documentation Standards Checklist

### ‚úÖ **Beginner-Friendly**

-   [ ] Use clear, simple language
-   [ ] Provide step-by-step instructions
-   [ ] Include "what you'll need" sections
-   [ ] Explain technical terms
-   [ ] Use consistent terminology

### ‚úÖ **Copy-Paste Ready**

-   [ ] All commands work as written
-   [ ] Include exact file paths
-   [ ] Provide complete command examples
-   [ ] Test all examples before publishing
-   [ ] Include expected outputs

### ‚úÖ **Up-to-Date**

-   [ ] Reflects current functionality
-   [ ] Matches actual command syntax
-   [ ] Uses correct file paths
-   [ ] References current versions
-   [ ] Removes outdated information

### ‚úÖ **Comprehensive**

-   [ ] Covers all features
-   [ ] Includes edge cases
-   [ ] Provides troubleshooting
-   [ ] Shows multiple examples
-   [ ] Explains error scenarios

### ‚úÖ **Well-Organized**

-   [ ] Logical structure
-   [ ] Clear headings
-   [ ] Consistent formatting
-   [ ] Cross-references between docs
-   [ ] Easy navigation

## üîÑ Documentation Workflow

### **Before Making Code Changes**

1. **Identify affected documentation**
    - Which docs need updates?
    - What examples will break?
    - What new features need explaining?

### **During Development**

2. **Update docs alongside code**
    - Don't wait until the end
    - Update as you develop
    - Test examples as you write them

### **Before Committing**

3. **Documentation review checklist**
    - [ ] All commands tested and working
    - [ ] Examples produce expected results
    - [ ] No broken links or references
    - [ ] Consistent formatting
    - [ ] Clear, beginner-friendly language

## üìã Specific Documentation Tasks

### **For README.md Updates**

-   Keep the "Quick Start" section current
-   Update command examples
-   Maintain the "What Does This Tool Do?" accuracy
-   Keep installation instructions current

### **For docs/GETTING_STARTED.md**

-   Test every command before updating
-   Verify all prerequisites are listed
-   Ensure troubleshooting section is current
-   Check that examples work for beginners

### **For New Feature Documentation**

-   Create examples that demonstrate the feature
-   Update relevant existing docs
-   Add to appropriate troubleshooting sections
-   Consider if new doc file is needed

## üö® Common Documentation Mistakes to Avoid

### ‚ùå **Don't Do This**

-   Leave outdated command examples
-   Use placeholder text like "TODO" or "Coming Soon"
-   Write docs after completing features
-   Assume users know technical terms
-   Skip testing examples

### ‚úÖ **Do This Instead**

-   Test every command before documenting
-   Write docs during development
-   Use clear, simple language
-   Provide complete, working examples
-   Update docs immediately when code changes

## üõ†Ô∏è Practical Implementation Steps

### **Step 1: Set Up Documentation Structure**

```bash
# Create missing documentation files
touch docs/TROUBLESHOOTING.md
touch docs/EXAMPLES.md
touch docs/API_REFERENCE.md
touch docs/CONFIGURATION.md
touch docs/CONTRIBUTING.md
```

### **Step 2: Establish Review Process**

-   **Before merging**: Check that docs are updated
-   **Code review**: Include documentation review
-   **Testing**: Test all documented examples
-   **Validation**: Ensure links work and examples run

### **Step 3: Create Documentation Templates**

Each doc file should have:

-   Clear title and purpose
-   Table of contents
-   Beginner-friendly introduction
-   Step-by-step instructions
-   Working examples
-   Troubleshooting section
-   Links to related docs

### **Step 4: Regular Maintenance**

-   **Weekly**: Review for outdated information
-   **Monthly**: Test all examples
-   **Per release**: Comprehensive documentation audit
-   **Per feature**: Immediate documentation update

## üéØ Success Metrics

### **Documentation Quality Indicators**

-   ‚úÖ New users can follow docs without help
-   ‚úÖ All examples work on first try
-   ‚úÖ Troubleshooting solves common issues
-   ‚úÖ Documentation stays current with code
-   ‚úÖ Users find information quickly

### **Red Flags to Watch For**

-   ‚ùå Users asking questions answered in docs
-   ‚ùå Examples that don't work
-   ‚ùå Outdated command syntax
-   ‚ùå Missing information about new features
-   ‚ùå Broken links or references

## üìû Documentation Support

### **When You Need Help**

-   **Stuck on wording?** ‚Üí Use simple, clear language
-   **Complex feature?** ‚Üí Break into smaller steps
-   **Technical concept?** ‚Üí Explain with analogies
-   **Multiple options?** ‚Üí Show examples for each
-   **Error scenarios?** ‚Üí Provide specific solutions

Remember: **Good documentation is a feature, not an afterthought.** It's what makes your project accessible to users and maintainable for contributors.
